#include "engine/function/render/render_resource/model.h"
#include "engine/function/render/render_resource/model_importer.h"
#include "engine/main/engine_context.h"
#include "engine/core/log/Log.h"
#include "engine/function/asset/asset_manager.h"

#include <algorithm>
#include <filesystem>
#include <fstream>
#include <string>

DEFINE_LOG_TAG(LogModel, "Model");

// CEREAL_REGISTER_TYPE and CEREAL_REGISTER_POLYMORPHIC_RELATION are now in model.h

Model::Model(std::string path, ModelProcessSetting process_setting)
    : path_(std::move(path)), process_setting_(std::move(process_setting)) {
}

Model::~Model() = default;

void Model::sync_slots_to_deps() {
    // Convert material_slots_ to mesh_deps_ and material_deps_
    // This is called before saving to ensure deps are up to date
    mesh_deps_.clear();
    material_deps_.clear();
    mesh_deps_.reserve(material_slots_.size());
    material_deps_.reserve(material_slots_.size());
    
    for (size_t i = 0; i < material_slots_.size(); ++i) {
        auto& slot = material_slots_[i];
        
        // Update indices
        slot.mesh_index = static_cast<uint32_t>(mesh_deps_.size());
        slot.material_index = static_cast<uint32_t>(material_deps_.size());
        slot.slot_index = static_cast<uint32_t>(i);
        
        // Add to deps (may be nullptr, that's OK)
        mesh_deps_.push_back(slot.mesh);
        material_deps_.push_back(slot.material);
    }
}

void Model::sync_deps_to_slots() {
    // Convert mesh_deps_ and material_deps_ back to material_slots_
    // This is called after loading when deps are resolved
    size_t slot_count = std::max(mesh_deps_.size(), material_deps_.size());
    if (slot_count == 0) {
        material_slots_.clear();
        return;
    }
    
    material_slots_.resize(slot_count);
    for (size_t i = 0; i < slot_count; ++i) {
        auto& slot = material_slots_[i];
        
        if (i < mesh_deps_.size()) {
            slot.mesh = mesh_deps_[i];
            slot.mesh_index = static_cast<uint32_t>(i);
        }
        if (i < material_deps_.size()) {
            slot.material = material_deps_[i];
            slot.material_index = static_cast<uint32_t>(i);
        }
        slot.slot_index = static_cast<uint32_t>(i);
    }
}

void Model::on_load_asset() {
    // ASSET_DEPS macro has already loaded mesh_deps_ and material_deps_
    // Now sync them to material_slots_
    sync_deps_to_slots();
    
    // Recalculate statistics
    total_vertex_ = 0;
    total_index_ = 0;
    for (const auto& slot : material_slots_) {
        if (slot.mesh) {
            total_vertex_ += slot.mesh->get_vertex_count();
            total_index_ += slot.mesh->get_index_count();
        }
    }
    clear_dirty();
}

void Model::on_save_asset() {
    // Sync material_slots_ to deps before saving
    sync_slots_to_deps();
    
    // Sync deps to UIDs for serialization (generated by ASSET_DEPS macro)
    save_asset_deps();
    
    // ASSET_DEPS macro will serialize mesh_deps_uid_ and material_deps_uid_
    clear_dirty();
}

std::shared_ptr<Model> Model::Load(const std::string& virtual_path, 
                                    const ModelProcessSetting& process_setting,
                                    const UID& explicit_uid) {
    if (!EngineContext::asset()) {
        ERR(LogModel, "AssetManager not initialized");
        return nullptr;
    }

    // Resolve virtual path to physical path or relative path
    std::string abs_path;
    
    auto physical_opt = EngineContext::asset()->get_physical_path(virtual_path);
    if (physical_opt) {
        abs_path = physical_opt.value().string();
    } else {
        // If not found in AssetManager, treat as relative path from executable
        abs_path = std::filesystem::absolute(virtual_path).string();
    }

    // Determine extension
    std::filesystem::path fs_path(abs_path);
    std::string ext = fs_path.extension().string();
    
    // Case 1: Engine Asset (.asset, .binasset)
    if (ext == ".asset" || ext == ".binasset") {
        // Try to load as native asset
        // If explicit_uid is provided, use it, otherwise try to resolve from path
        UID uid = explicit_uid;
        if (uid.is_empty()) {
            uid = EngineContext::asset()->get_uid_by_path(virtual_path); // Try virtual path first
            if (uid.is_empty()) {
                 uid = EngineContext::asset()->get_uid_by_path(abs_path); // Then physical
            }
        }
        
        if (!uid.is_empty()) {
            return EngineContext::asset()->load_asset<Model>(uid);
        }
        
        ERR(LogModel, "Failed to load native model asset: {} (UID not found)", virtual_path);
        return nullptr;
    }

    // Case 2: Import from Source (FBX, OBJ, GLTF, etc.)
    
    // Check cache by path/UID first
    UID uid = explicit_uid.is_empty() ? EngineContext::asset()->get_uid_by_path(abs_path) : explicit_uid;
    if (uid.is_empty()) {
        // Try getting UID from virtual path as fallback
        uid = EngineContext::asset()->get_uid_by_path(virtual_path);
    }

    if (!uid.is_empty()) {
        auto cached = EngineContext::asset()->get_asset_immediate(uid);
        if (cached) {
            auto model = std::dynamic_pointer_cast<Model>(cached);
            if (model) {
                INFO(LogModel, "Model cache hit: {}", abs_path);
                return model;
            }
        }
    }

    // Import using ModelImporter
    INFO(LogModel, "Importing model from source: {}", abs_path);
    ModelImporter importer;
    auto model = importer.import_model(abs_path, virtual_path, process_setting);
    
    if (model) {
        if (!explicit_uid.is_empty()) {
            model->set_uid(explicit_uid);
        } else if (model->get_uid().is_empty()) {
            // Importer might have set a deterministic UID based on path, if not, generate one
            model->set_uid(UID::from_hash(virtual_path.empty() ? abs_path : virtual_path));
        }
        
        // Sync slots to deps before saving
        model->sync_slots_to_deps();
        
        // Save the model asset (this will also save dependencies via ASSET_DEPS)
        std::string model_asset_path = virtual_path.empty() ? abs_path : virtual_path;
        if (!model_asset_path.ends_with(".asset") && !model_asset_path.ends_with(".binasset")) {
            model_asset_path += ".asset";
        }
        EngineContext::asset()->save_asset(model, model_asset_path);
        
        INFO(LogModel, "Model imported successfully: {} slots", model->get_slot_count());
    } else {
        ERR(LogModel, "Failed to import model: {}", abs_path);
    }
    
    return model;
}

std::shared_ptr<Model> Model::Load(const std::string& path, 
                                    bool smooth_normal,
                                    bool load_materials,
                                    bool flip_uv,
                                    const UID& explicit_uid) {
    ModelProcessSetting setting;
    setting.smooth_normal = smooth_normal;
    setting.load_materials = load_materials;
    setting.flip_uv = flip_uv;
    return Load(path, setting, explicit_uid);
}

std::shared_ptr<Model> Model::Create(MeshRef mesh, MaterialRef material) {
    auto model = std::make_shared<Model>();
    model->add_slot(mesh, material);
    return model;
}

std::shared_ptr<Model> Model::Create(const std::vector<std::pair<MeshRef, MaterialRef>>& slots) {
    auto model = std::make_shared<Model>();
    for (const auto& [mesh, material] : slots) {
        model->add_slot(mesh, material);
    }
    return model;
}

void Model::add_slot(MeshRef mesh, MaterialRef material) {
    MaterialSlot slot;
    slot.mesh = mesh;
    slot.material = material;
    slot.mesh_index = static_cast<uint32_t>(mesh_deps_.size());
    slot.material_index = static_cast<uint32_t>(material_deps_.size());
    slot.slot_index = static_cast<uint32_t>(material_slots_.size());
    
    material_slots_.push_back(slot);
    
    // Also add to deps for immediate consistency
    mesh_deps_.push_back(mesh);
    material_deps_.push_back(material);
    
    if (mesh) {
        total_vertex_ += mesh->get_vertex_count();
        total_index_ += mesh->get_index_count();
    }
    mark_dirty();
}

void Model::set_material(uint32_t slot_index, MaterialRef material) {
    if (slot_index < material_slots_.size()) {
        material_slots_[slot_index].material = material;
        if (slot_index < material_deps_.size()) {
            material_deps_[slot_index] = material;
        }
        mark_dirty();
    }
}

MaterialRef Model::get_material(uint32_t slot_index) const {
    if (slot_index < material_slots_.size()) {
        return material_slots_[slot_index].material;
    }
    return nullptr;
}

MeshRef Model::get_mesh(uint32_t slot_index) const {
    if (slot_index < material_slots_.size()) {
        return material_slots_[slot_index].mesh;
    }
    return nullptr;
}

VertexBufferRef Model::get_vertex_buffer(uint32_t index) const {
    auto mesh = get_mesh(index);
    return mesh ? mesh->get_vertex_buffer() : nullptr;
}

IndexBufferRef Model::get_index_buffer(uint32_t index) const {
    auto mesh = get_mesh(index);
    return mesh ? mesh->get_index_buffer() : nullptr;
}

BoundingBox Model::get_bounding_box() const {
    BoundingBox result;
    bool first = true;
    
    for (const auto& slot : material_slots_) {
        if (slot.mesh) {
            const auto& box = slot.mesh->get_bounding_box();
            if (first) {
                result = box;
                first = false;
            } else {
                result.min = result.min.cwiseMin(box.min);
                result.max = result.max.cwiseMax(box.max);
            }
        }
    }
    
    return result;
}
